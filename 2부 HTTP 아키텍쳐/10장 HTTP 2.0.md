- 본 서의 내용은 HTTP/2.0의 8번째 초안을 기준으로 작성됐다.
- 내용:
    - 2.0의 특징
    - 배경
    - 1.1과 차이
    - 알려진 보안 이슈

# 10.1 HTTP/2.0 등장 배경
- HTTP/1.1의 주안점: 구현 단순성, 접근 용이성
    - 단점: 성능
        - 회전 지연: 응답을 받을 때까지 기다릴 수 밖에 없기에 생기는 지연
        - 제시 해결책: 병렬 커넥션([[4장 커넥션 관리#4 4 병렬 커넥션|4.4]]), 파이프라인 커넥션([[4장 커넥션 관리#4 6 파이프라인 커넥션|4.6]])
        - 한계: 근본적 해결책이 되진 못함.
    - 단점을 극복하려던 노력들:
        - HTTP-NG
        - WAKA 프로토콜
        - MS의 S+M(Speed+Mobility)
        - 구글의 SPDY 프로토콜 <- 이후 장의 주요 내용
            - 특징(전부 회전 지연을 줄이기 위한 것들):
                - 헤더 압축(10.3.3)
                - 한 TCP 커넥션에 여러 요청을 동시 전송(10.3.2)
                - 요청을 받지 않아도 서버가 능동적으로 리소스 푸시(10.3.4)
            - 개선 성과를 인정 받아 HTTP/2.0 설계의 기반이 됨.

# 10.2 개요
- TCP 커넥션 상에서 동작하며 초기화는 클라이언트의 역할이다.
- 요청과 응답은 프레임이라는 정의된(최대 16383바이트) 단위에 담긴다.
- 헤더는 압축된다.
- 요청과 응답 한 쌍은 스트림이라는 단위로 커넥션을 오간다. 
    - 메시지와 달리 한 커넥션에서 동시에 만들어져 여러 번 오갈 수 있다. 
    - 스트림은 우선 순위를 매길 수 있다.
- 서버 푸시: 클라이언트가 요청하진 않았지만 필요하다고 서버가 판단한 리소스를 먼저 보낼 수 있다.
- 1.1과 공통/차이점:
    - 요청과 응답 메시지 의미를 같게 유지: 여전히 `Content-Length`는 본문 길이, `404 Not Found`는 요청 리소스 미발견 의미.
    - 문법은 변경: `Content-Length `-> `content-length` 헤더, 상태 코드와 사유 구절이었던 `404 Not Found`는 `:status` 헤더가 됨.

# 10.3 HTTP/1.1과 차이점

## 10.3.1 프레임
- 메시지를 대신할 단위
- 헤더(8 bytes) + 페이로드(최대 16383 bytes)
    ![[frame.jpg]]
    - 각 필드의 의미:
        - R(Reserved): 값의 의미는 정의돼 있지 않으며, 0이어야 한다. 수신측은 이를 무시한다. 
        - 길이: 페이로드의 길이. 14 bits unsigned int형. 프레임 헤더 길이는 포함되지 않는다.
        - 종류: 프레임 종류
            - DATA
            - HEADERS
            - PRIORITY
            - RST_STREAM
            - SETTINGS
            - PUSH_PROMISE
            - PING
            - GOAWAY
            - WINDOW_UPDATE
            - CONTINUATION
        - 플래그 8 bits로 값이 뭘 의미하는지는 프레임 '종류'에 따라 변한다.
        - R: 값 의미는 미정이며 먼젓번 R과 동일하게 0값이다. 수신측은 이를 무시한다.
        - 스트림 식별자: 0이라면 커넥션 전체와 연관된 프레임을 의미. 바로 아래 10.3.2에서 자세한 설명을 하고 있다.

## 10.3.2 스트림과 멀티플렉싱
- 프레임들의 독립된 양방향 시퀀스
- 스트림은 요청과 응답으로 이루어진다.
- 스트림을 통한 통신 과정:
    1. 클라이언트가 새 스트림을 생성해 요청
    2. 같은 스트림으로 서버가 응답을 보낸다.
    3. 스트림 폐쇄.
- 한 커넥션에 여러 스트림 동시 개방 가능:
    - 1.1의 메시지 교환 방식에선:
        - 메시지는 응답 도착 후 요청을 보낼 수 있다.
        - 이를 위해 병렬 conn을 생성했다
        - 병렬 커넥션 수에는 한계가 있다.
        - 파이프라인 커넥션은 좀 나으나 구현된 애플리케이션이 적다.
- 스트림은 우선 순위를 매길 수 있다.
    - 우선 순위는 의무 사항이 아니므로 요청이 이 순서대로 받아들여지지 않을 수 있다.
- 스트림마다 31 bits unsigned int 형식인 고유한 식별자가 부여되야 한다.
    - 식별자 규칙:
        - 홀수: 클라이언트에 의해 초기화 됨
        - 짝수: 서버에 의해 초기화 됨.
        - 새 스트림은 이전에 만들어졌거나 예약된 스트림보다 큰 식별자를 받아야 한다.
    - 식별자 규칙에 맞지 않는 스트림을 수신하면 `PROTOCOL_ERROR` 커넥션 에러로 응답할 것.
    - 한번 사용한 식별자는 다시 사용 불가. 식별자 고갈 시에는 커넥션을 끊고 새로 맺어라.
    - 병렬 스트림 사용 시 블록 될 우려가 있다면 `WINDOW_UPDATE` 프레임으로 흐름 제어를 해 간섭에 의한 에러를 막아라%%무슨 소린지 사실 잘 모르겠어%%.

## 10.3.3 헤더 압축
- 필요성: 이전에는 보낼 헤더가 적었으나 이제는 헤더 영역의 크기가 커 회전 지연, 대역폭에 영향을 미친다.
- 과정:
    1. HPACK 명세에 정의된 압축 방법으로 압축
    2. 헤더 블록 조각으로 분할
    3. 수신자는 조각을 병합
    4. 병합 후 압축 해제
- HPACK은 압축과 해제 과정에 압축 콘텍스트(compression context)를 사용
    - 압축을 풀면 콘텍스트는 변한다.
    - 송신자는 콘텍스트가 변경을 가정하기에 수신자는 헤더를 쓸 일이 없어도 무조건 압축을 풀어야 한다.
    - 압축을 해제하지 못했다면 COMPRESSION_ERROR를 보내고 커넥션을 종료해야 한다.

## 10.3.4 서버 푸시
- 서버는 클라이언트가 요청하지 않았더라도 리소스를 보낼 수 있다.
    - HTML 문서를 요청 받았다면 딸린 정적 리소스도 당연히 필요할 것이므로 이를 푸시로 보내면 회전 지연을 줄일 수 있다.
- 리소스 푸시 과정:
    1. 서버는 클라이언트에게 미리 PUSH_PROMISE 프레임을 보내 서버가 보내려는 자원을 클라이언트가 중복 요청하는 상황을 방지해야 한다.
    2. 클라이언트가 프레임을 받으면 통신 중이던 스트림은 클라이언트 입장에서 '예약됨(원격)' 상태가 된다.
    3. 스트림이 유지 중인 동안 클라이언트는 리소스를 받는다. 클라이언트는 서버가 푸시하려는 리소스의 요청을 보내선 안된다.
    4. 클라이언트는 RST_STREAM 프레임을 보내 푸시를 거절하면 스트림은 즉각 닫힌다.
- 서버 푸시 시 주의점:
    - 중간 프락시는 푸시된 리소스를 클라이언트에게 전달하지 않을 수 있으며, 서버가 보내지 않은 리소스를 전달할 수 있다.
    - 푸시 리소스는 클라이언트가 요청했던 리소스와 관련 있는 것만 가능하며, 그 때의 요청을 보낸 스트림으로 푸시해야 한다.
    - 서버가 푸시를 보낼 수 있는 이전 요청의 조건: 안전하며, 캐시 가능, 본문이 없어야 한다.
    - 푸시된 리소스를 받으면 반드시 동일 출처 정책(same-origin policy)에 따라 검사할 것.
    - 서버 푸시 기능을 끄고 싶다면 SETTINGS_ENABLE_PUSH을 0으로 설정할 것.

# 10.4 알려진 보안 이슈

## 10.4.1 중개자 캡슐화 공격(intermediary encapsulation attacks)
- 2.0 -> 1.1 변환 과정에서 메시지가 변질될 수 있다. (역방향은 안심)
- 이유: 
    - 1.1과 달리 2.0은 헤더 필드명과 그 값을 바이너리로 인코딩
    - 헤더 필드에 어떤 문자열이든 포함될 수 있게 된다.

## 10.4.2 긴 커넥션 유지로 인한 개인정보 유출 우려
- 원인: 회전 지연을 막으려는 스트림 방식은 커넥션이 장기 유지되기 쉽다.
- 예상 문제점: 의도치 않게 유지 중인 커넥션을 누군가 다시 활용할 수 있다.
- 악용 예시: 커넥션이 아직 유지 중인 상태에서 이전 브라우저 사용자의 동작을 추적할 수 있다. 