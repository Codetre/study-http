- 이 장의 질문
    - 프락시와 게이트웨이 비교
    - 프락시 배치
    - 프락시를 경유하는 메시지에는 무슨 일이 생기는가
    - 브라우저가 프락시를 사용하도록 설정하는 법
    - 프락시 요청과 서버 요청 차이
    - 프락시로 구현한 접근 제어
    - 프락시 상호운용성

# 6.1 웹 중개자
- 프락시 역할: 트랜잭션의 중개인.
    - 클라이언트로서: 원래 서버에게 요청을 보내고 받은 응답을 원래 서버에게 돌려준다.
    - 서버로서: 원래 클라이언트에게 받은 요청을 원래 서버에게 전달한다.
    ```mermaid
    graph LR;  
        Client-->Proxy;
        Proxy-->Client;
        Proxy-->Server;
        Server-->Proxy;
    ```
## 6.1.1 개인 프락시와 공유 프락시
- 개인 프락시: 하나의 클라이언트에만 연결된 경우
    - 사용 예: 브라우저 기능 확장
- 공용 프락시: 다수의 클라이언트에 연결된 경우
    - 이점: 중앙 집중형으로서 비용 효율이 높다.
    - 이용자가 많을수록 공통된 요청이 늘어 캐시 같은 경우 이득.

## 6.1.2 프락시 대 게이트웨이
- 프락시: 같은 프로토콜을 사용하는 둘 이상의 어플리케이션 연결
- 게이트웨이: 서도 다른 프로토콜을 사용하는 둘 이상의 어플리케이션 연결
- 구분이 어려운 경우:
    - 게이트웨이 기능을 겸한 프락시 서버
    - 브라우저와 서버가 다른 버전 HTTP를 구현했기에 이를 맞추려 프록시가 프로토콜 변환하는 경우.

# 6.2 왜 프락시를 사용하는가
- 활용 사례:
    - 보안 개선: 문서 접근 제어자, 보안 방화벽, 익명화 프락시
    - 성능 향상: 웹 캐시, 서버 가속기(대리/리버스 프락시), 콘텐츠 라우터
    - 비용 절약: 웹 캐시,
    - 트래픽 감시 및 수정: 불건전 컨텐츠 필터링, 트랜스코딩

# 6.3 프락시는 어디에 있는가
## 6.3.1 프락시 서버 배치
프락시는 사용 용도에 따라 네트워크 내 어디에나 배치될 수 있다.
- 출구(Egress) 프락시
    - 위치: 로컬 네트워크 출구
    - 목적: 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽 제어
- 접근(입구) 프락시
    - 위치: ISP 접근 지점
    - 목적: 고객들에게 오는 모든 요청을 종합적으로 처리
- 대리 프락시
    - 위치: 네트워크 말단에 있는 웹 서버들의 바로 앞
    - 목적: 웹 서버로 향하는 모든 요청을 먼저 받고 필요할 때만 서버에게 자원 요청
- 네트워크 교환 프락시
    - 위치: 네트워크 사이의 인터넷 피어링[^peering] 교환 지점
    - 목적: 캐시를 이용해 인터넷 교차로의 혼잡을 완화, 트래픽 흐름 감시

[^peering]: 인터넷 서비스 제공자(ISP)끼리 서로 네트워크를 연결하고 트래픽을 교환하는 것 ^peering

## 6.3.2 프락시 계층
- 프락시 계층: 프락시1 -> 프락시2 -> 프락시3 ... 연쇄적으로 다음 프락시에게 메시지 전달
- 부모/자식 관계: 프락시 계층 속 두 프락시 관계를 살펴 보면...
    - 부모: 인바운드 방향의 프락시
    - 자식: 아웃바운드 방향의 프락시
- 정적/동적 구분:
    - 정적 프락시 계층: 메시지가 진행되는 방향이 항상 일정.
    - 동적 프락시 계층: 메시지 진행 방향이 프락시의 판단에 의해 결정됨.
        - 예: 캐시된 객체가 있으면 요청을 캐시 서버로, 아니라면 원래 서버로 전달.
        - 예: 느린 대역폭의 경우 원본 이미지 대신, 압축본을 전송하는 압축 프록시로 메시지 전달.
        - 부모 선택의 몇 가지 기준:
            - 부하 균형: 부하 분산을 위해 부모들의 작업량에 근거하여 다음 부모 프락시 결정.
            - locality: 원래 서버의 지역에 속한 프록시를 부모로 결정
            - 프로토콜/타입 라우팅: URI를 근거로 부모를 결정
            - 유료 서비스 가입자를 위한 라우팅: 가입자는 더 빠른 대형 캐시나 압축 엔진으로 부모를 결정.

## 6.3.3 어떻게 프락시가 트래픽을 처리하는가
- 클라이언트-서버 직접 연결 대신 프락시를 경유하도록 만드는 방법:
    - 클라이언트를 수정([[6장 프락시#6 4 클라이언트 프락시 설정|상세]]): 브라우저 같은 클라이언트가 프락시를 사용하도록 설정.
    - 네트워크를 수정: 네트워크 인프라를 가로챈다. 인터셉트 프락시[^intercept proxy] 필요.
    - DNS 이름 공간을 수정: 대리 프락시의 경우 원래 서버의 IP 주소와 도메인명을 자신이 획득한다. 이는 동적 DNS 서버에서 DNS 테이블을 편집해서 구현.
    - 웹 서버를 수정: HTTP 리다이렉션 응답에 프락시를 지정하여 이동하도록 클라이언트에게 안내한다.

[^intercept proxy]: HTTP 트래픽을 감시하며 클라이언트 모르게 이 트래픽을 프락시로 보내는 스위칭/라우팅 장치.


# 6.4 클라이언트 프락시 설정
- 수동 설정([[6장 프락시#6 4 1 수동 설정|6.4.1]]): 사용할 프락시를 명시
- 브라우저 기본 설정([[6장 프락시#6 4 1 수동 설정|6.4.1]]): 벤더나 배포자가 브라우저 배포 전에 미리 지정
- 프락시 자동 설정(Proxy auto-configuration, PAC)([[6장 프락시#6 4 1 수동 설정|6.4.2]]): JS로 작성된 PAC 파일의 URI를 제공. 이 파일에는 클라이언트가 어떤 프락시를 언제 쓰는지 규칙이 명시돼 있다.
- WPAD 프락시 발견([[6장 프락시#6 4 1 수동 설정|6.4.3]]): PAC를 제공하는 설정 서버를 자동으로 검색. Web Proxy Auto-discovery Protocol

## 6.4.1 수동 설정
브라우저의 설정에서 프락시의 호스트와 포트를 지정함으로써 요청이 프락시를 지나가게끔 설정할 수 있다.

## 6.4.2 PAC
- 수동 설정의 문제점: 유연하지 못함.
    - 지정 프락시가 1개 뿐.
    - 장애 시 fallback 마련 없음.
- 동적인 해결책인 PAC: 리소스에 따라 어느 프락시를 사용할지 결정.
- PAC의 사용 방법: 
    1. PAC 파일 정의: URL별 프락시를 찾는 `FindProxyForUrl(url, host)` 함수 정의.
        - 리턴값(문자열)
            - 경유 없음: `"DIRECT"`
            - 프록시 지정: `"PROXY <host>:<port>"`
            - SOCKS 서버 지정: `"SOCKS <host>:<port>"`
    1. PAC의 URI를 '자동 설정' 항목에 제공
- `.pac` 확장자, 'application/x-ns-proxy-autoconfig' MIME 타입.

## 6.4.3 WPAD
- WPAD란: 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘.
- 이용 과정:
    1. WPAD로 PAC 파일의 URI를 탐색.
    2. URI에서 파일을 내려 받는다.
    3. PAC 파일로 프록시 위치를 알아낸다.
    4. 요청을 프록시로 전송한다.
- 리소스 발견 기법(제품마다 이 중 일부를 순서대로 실행)
    - 동적 호스트 발견 규약(DHCP)
    - 서비스 위치 규약(SLP)
    - DNS 잘 알려진 호스트명
    - DNS SRV 레코드
    - DNS TXT 레코드 내 서비스 URI

# 6.5 프락시 요청의 미묘한 특징들
- 프락시 요청의 URI는 서버 요청과 뭐가 다른가([[6장 프락시#6 5 1 프락시 URI는 서버 URI와 다르다|6.5.1]])
- 인터셉트 프락시와 리버스 프락시는 어떻게 서버 호스트 정보를 알아내기 어렵게 만드는가([[6장 프락시#6 5 3 인터셉트 프락시는 부분 URI를 받는다|6.5.3]])
- URI 수정 규칙([[6장 프락시#6 5 5 전송 중 URI 변경|6.5.5]])
- 프락시는 브라우저 똑똑한 URI 자동완성, 호스트명 확장 기능에 어떻게 영향을 미치는가.([[6장 프락시#6 5 6 URI 클라이언트 자동 확장과 Hostname resolution|6.5.6(일반 hostname resolution, 확장 설명)]], [[6장 프락시#6 5 6 URI 클라이언트 자동 확장과 Hostname resolution|6.5.7()]], [[6장 프락시#6 5 6 URI 클라이언트 자동 확장과 Hostname resolution|6.5.8]], [[6장 프락시#6 5 6 URI 클라이언트 자동 확장과 Hostname resolution|6.5.9]])

## 6.5.1 프락시 URI는 서버 URI와 다르다
- 서버와 프락시 메시지 차이점: 요청 URI가 다름.
    - 서버 메시지: 부분 URI
        ```
        GET /index.html HTTP/1.0
        User-Agent: SuperBrowserv1.3
        ```
    - 프락시 메시지: 완전한 URI
        ```
        GET http://marys-antique.com/index.html HTTP/1.0
        User-Agent: SuperBrowserv1.3
        ```
- 다른 이유
    - 배경:
        - HTTP 초창기 클라이언트-서버 통신 간 중개 노드를 상정하지 않았음.
        - 요청 URI는 스킴, 호스트, 포트 번호를 포함할 필요가 없었음.
    - 문제점 부상:
        - 프락시-서버 커넥션을 위해 호스트와 포트 번호가 필요
        - 게이트웨이 기능을 위해서는 스킴이 필요
- 클라이언트 프락시 사용 여부:
    - 사용함: 완전한 URI로 요청 전송
    - 미사용함: 부분 URI로 요청 전송

## 6.5.2 가상 소스팅에서 일어나는 같은 문제
단일 물리 서버 내 여러 호스팅이 존재하는 가상 호스팅도 부분 URI에 의한 문제가 일어난다. 
- 해결책 차이:
    - 프락시: 완전한 URI를 기입.
    - 가상 호스팅: Host 헤더에 호스트와 포트 정보를 담는다.

## 6.5.3 인터셉트 프락시는 부분 URI를 받는다
대리 프락시나 인터셉트 프락시는 클라이언트가 자신의 존재를 모르는 채 요청을 보내기에 부분 URI를 받는 문제가 있다.

## 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다
다목적 프락시 서버는 완전한 URI와 부분 URI를 모두 다룰 수 있어야 한다.
- 사용 규칙:
    1. 완전한 URI가 존재하면 그걸 사용.
    2. 부분 URI만 존재
        1. Host 헤더가 존재: 이를 이용해 서버의 호스트명과 포트를 획득
        2. Host 헤더 미존재: 서버의 호스트명과 포트를 획득하기 위해서...
            - 대리 프락시면 내장된 실제 서버의 주소와 포트를 사용
            - 인터셉트 프락시가 가로챘던 메시지에 서버 IP와 포트가 있다면%%인터셉트 메시지는 어떻게 서버 정보를 알 수 있지?%% 그걸 사용.
            - 실패 시: (보통 서버 정보를 Host헤더에 붙여달라는) 에러 메시지를 클라이언트에게 반환.

## 6.5.5 전송 중 URI 변경
- URI 변경은 상호운용성을 망가뜨릴 수 있다.
    - 예시: URI 정규화
- 원칙: 보낼 때는 엄격히, 받을 때는 관대하게
- 인터셉트 프록시는 빈 경로를 '/'로 교체하는 경우 빼고는 절대 URI를 수정해선 안된다.

## 6.5.6 URI 클라이언트 자동 확장과 Hostname resolution
(자동 확장을 다시 보여주는 부분이니, [[2장 URL과 리소스#2 3 2 URL 확장]] 참조.)

## 6.5.7 프락시 없는 URI 분석(resolution)
(호스트명 분석을 다시 보여주는 부분이니, [[2장 URL과 리소스#2 3 2 URL 확장]] 참조.)

## 6.5.8 명시적인 프락시를 사용할 때의 URI 분석
브라우저는 프락시를 사용하도록 명시된 경우, 확장이나 분석 기능을 사용하지 않는다.

## 6.5.9 인터셉트 프락시를 이용한 URI 분석

# 6.6 메시지 추적
클라이언트-서버 간 커넥션 사이에 노드가 놓이는 경우가 흔해져, 프락시를 넘나드는 메시지 추적이 중요해졌다.

## 6.6.1 Via 헤더
- Via 헤더: 메시지가 지나가는 중간 노드의 정보를 나열. 중간 노드는 자신을 나타내는 유일한 문자열을 반드시 Via 헤더 끝에 추가해야 한다.
    - 예: `Via: 1.1 proxy-62.irenes-isp.net 1.0 cache.joes-hardware.com`
- 용도
    - 메시지 전달 추적
    - 메시지 루프 진단
    - 각 노드의 프로토콜 지원 능력 알아보기
    - 라우팅 루프 탐지
- Via 문법
    - Via = `"Via" ":" ( waypoint ) [", " ( waypoint )...]`
    - waypoint = `( received-protocol received-by [ comment ] )`
    - received-protocol = `[ protocol-name "/"] protocol-version`
    - received-by = `( host [ ":" port ] ) | pseudonym`
- Via 구성 요소
    - 프로토콜명: HTTP는 생략 가능. 
    - 프로토콜 버전: 필수 사항. 
    - 노드 이름: 호스트명과 포트 번호(생략 시 사용 프로토콜의 기본 포트). 보안을 위해 가명 사용 가능.
    - 노드 주석: 중개자 노드를 서술. 흔히 벤더나 버전 정보 기술. 
- 요청과 응답은 대부분 반대 순서로 node가 기술돼 있다. 
- 게이트웨이 프록시 경유 시 Via에 프로토콜 변환이 기록됨.
    - 요청: `GET ftp://http-guide.com/pub/welcome.txt HTTP/1.0`
    - 응답: 
    ```
    HTTP/1.0 200 OK
    Date: ...
    Via: FTP/1.0 proxy.irenes-isp.net (Traffic-Server/5.0.1-17882)
    Last-modified:...

    Hi there. This is an FTP server.
    ```
- Server 헤더: 서버에 의해 사용되는 소프트웨어 정보. 프락시는 절대 이 부분을 수정해서는 안된다.
- Via 숨김: 정확한 호스트명을 헤더에 넣질 않기 원하는 경우
    - 프락시가 네트워크 방화벽의 일부인 경우: 호스트 정보 대신 가명 사용.
    - Via에 나열된 인접 항목들을 하나로 합침: `Via: 1.0 foo, 1.0 devirus.company.com 1.1 access-logger.company.com` -> `Via: 1.0 foo, concealed-stuff`
        - 합쳐선 안되는 경우
            - 수신된 프로토콜이 다른 경우
            - 경유지가 다른 조직에 속하는 경우
            - 호스트가 가명으로 교체된 경우

## 6.6.2 TRACE 메서드
- 프락시 서버는 자신에게 들어온 메시지를 수정할 수 있다. 
    - 헤더 추가, 변경, 삭제
    - 본문 형식 변경
- TRACE 메서드 역할: 메시지의 변경 비교
- TRACE 작동: 서버는 자신이 받은 요청의 전체 내용을 엔터티로 응답 메시지를 발송한다.
- Max-Forwards: TRACE와 OPTIONS 요청이 지날 수 있는 다음 프락시 Hop의 수를 제한([[6장 프락시#6 8 프락시 상호운용성|6.8]] 참고)하는 정수를 값으로 지님.
        - `Max-Forwards: 0`이 되면 그때의 프록시는 즉시 응답을 클라이언트에게 돌려줘야 한다.
        - `Max-Forwards: n`(n>0)이면 다음 홉으로 전달 전에 n-1로 갱신해야 한다.
        - 모든 프락시와 게이트웨이는 Max-Forwards 헤더를 지원해야 한다.

# 6.7 프락시 인증
- 접근 제어 장치로 프락시 사용 가능
- 구현 수단: 사용자가 유효한 접근 권한 자격을 제출하지 않는 한 콘첸트에 대한 요청을 차단하는 기능인 '프락시 인증'를 HTTP 명세에 정의.
- 프락시 [[12장 기본 인증|인증]] 과정:
    1. 프락시가 제한된 컨텐츠 접근 요청을 받아 응답:
        - 407 코드: Proxy Authorization Required
        - Proxy-Authenticate 헤더: 자격 제출 방법 설명.
    2. 클라이언트는 응답 요구에 따라 자격 증명에 필요한 정보 수집
    3. 프락시가 클라이언트에게 재요청을 받으면...
        - with 유효한 자격: 다음 노드로 전달.
        - 유효하지 않은 자격: 407 응답 반환.
- 프락시 인증은 여러 노드로 이루어진 [[6장 프락시#6 3 2 프락시 계층|프락시 계층]]에서는 실패할 수 있다.

# 6.8 프락시 상호운용성
상호운용성의 의미: 서버, 클라이언트, 프락시의 지원 HTTP 버전, 벤더, 지원 기능이 제각각인 경우 이들을 중개할 수 있어야 한다.

## 6.8.1 지원하지 않는 헤더와 메서드 다루기
- 지원하지 않는 헤더: 그대로 전달.
- 같은 이름의 헤더가 여럿인 경우: 상대적인 순서도 유지하며 전달.
- 지원하지 않는 메서드: 그대로 전달.

## 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기
- OPTIONS: 서버의 리소스에 어떤 메서드를 사용할 수 있는지 확인
    - 상호운용성 구현 전 파악을 위해 사용
    - 예시: `OPTIONS * HTTP/1.1` 서버 전체 리소스 범위에서 사용할 수 있는 메서드.
    - 예시: `OPTIONS /index.html HTTP 1.1` 특정 리소스에 사용할 수 있는 메서드.
- OPTIONS의 성공 응답: 가능한 메서드를 나열한 헤더 필드를 포함하여 200 OK 반환.
    - HTTP/1에는 'Allow' 헤더만이 지원 메서드 서술을 위해 정의돼 있다.

## 6.8.3 Allow 헤더
- 기능:
    - 자원별 지원 메서드 혹은 서버 전체 지원 메서드를 나열.
        - 예시: `Allow: GET, OPTIONS, HEAD`
    - 서버가 지원하길 바라는 메서드 추천.
        - 서버는 여기에 반드시 응할 의무는 없다.
        - 이 요청의 응답에는 실제로 지원 중인 메서드를 Allow에 열거해야 한다.
- 프락시가 주의해야 할 사항: Allow 헤더 속 메서드 중 이해할 수 없는 것이 있더라도 헤더를 수정해선 안된다.
