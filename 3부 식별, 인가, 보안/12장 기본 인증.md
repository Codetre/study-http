- 인증의 의미: 당신이 누구인지 증명하는 행위. 서버는 당신이 누구인지 식별할 수 있어야 한다.
- 인증이 필요한 이유: 허가된 사람만이 데이터에 접근하고 업무를 처리해야 하기 때문
- 인증이 필요한 사례들:
    - 개인 소유 문서는 권한 있는 자만 열람 가능해야 함
    - 기업 비밀 문서는 임원 등 필요한 사람만 열람 가능해야 함
- 여기서 다루는 인증의 종류: HTTP 인증, 기본 인증, 다이제스트 인증

# 12.1 인증(Authentication)
- 인증 사례:
    - 스마트폰 잠금 해제 입력
    - 컴퓨터 대화상자에 비밀 번호 입력
- 인증의 불완전성: 허가 받지 않은 사람이 인증할 위험도 도사린다.
- 인증의 필요성: 인증 요구 정보는 그럼에도 당신을 식별하는데 필요.

## 12.1.1 HTTP 인증 요구/응답 프레임워크
- 간단한 인증 요구/응답 모델
    1. CLI: 문서 요청
    2. SRV: 인증 요구를 응답에 실어 보낸다.
    3. CLI: 인증 정보를 문서 요청에 실어 보낸다.
    4. 인증 성공 시 서버는 문서를, 실패 시 인증 재요구나 실패 응답을 전송.

## 12.1.2 인증 프로토콜과 헤더
- HTTP에는 여러 인증 프로토콜이 있다:
    - 기본 인증(HTTP 공식)
    - 다이제스트 인증(HTTP 공식)
    - [OAuth](http://tools.ietf.org/html/rfc6749)
- 다양한 인증 프로토콜이 있으며, 이 중 하나를 잡고 헤더를 커스터마이징하여 확장 가능한 인증 프레임워크를 만든다. 이렇게 만든 프레임워크를 HTTP가 제공한다. %%솔직히 무슨 말인지 모르겠다%%

| 단계 | 헤더 | 설명 | 메서드(혹은 상태) |
| -- | -- | -- | -- |
| 요청 | - | - | GET |
| 인증 요구 | WWW-Authenticate | 인증 정보(ID, PW), 헤더에 어떤 영역(realm)의 인증이 필요한지 기술 | 401 Unauthorized |
| 인증 | Authorization | 인증 정보를 요청에 실어 보낸다. | GET |
| 성공 | Authentication-Info | 인증이 정확하면 문서를 보내며, 인증 세션에 관한 추가 정보를 같이 보내기도 한다. | 200 OK |

- 간단한 인증 요구/응답 모델([[12장 기본 인증#12 1 1 HTTP 인증 요구 응답 프레임워크|12.1.1]]의 과정을 상세히 풂)
    1. CLI: GET 메서드로 문서를 요청한다.
    2. SRV: WWW-Authenticate에 어떤 영역의 비밀번호가 필요한지를 기술한 인증 요구를 401(Unauthorized) 응답에 실어 보낸다.
    3. CLI: 인증 정보를 Authorization 헤더에 넣어 문서 요청에 실어 보낸다.
    4. SRV 인증 응답:
        1. 성공 시 서버는 세션 추가 정보를 Authentication-Info에 실어 요청 문서와 함께 200 OK로 응답한다. 
        2. 실패 시 인증 재요구나 실패 응답을 전송.

## 12.1.3 보안 영역
- 질문: HTTP는 어떻게 각 리소스마다 접근 조건을 달리 걸 수 있는가?
    - 답: 보안 영역(realm)을 설정한다.
- 보안 영역: 동일한 사용자 권한을 요구하는 리소스끼리 묶음.
- 예시: realm="family", realm="company"로 설정하면 family 내 리소스 요청 시 family에 맞는 인증 정보를 제공해야 하며, 이는 company에서는 인증 실패한다.
    ```
    # realm 지정 인증 요구 응답
    HTTP/1.0 401 Unauthorized
    WWW-Authenticate: Basic realm="Corporate Financials"
    ```

# 12.2 기본 인증
- 가장 잘 알려진 HTTP 인증 프로토콜로 거의 모든 CLI/SRV에 구현돼 있다.
- 인증 명세: 기본 인증은 HTTP/1.0이었다 RFC2617로 이관됐다.
- 기본 인증 과정: [[12장 기본 인증#12 1 2 인증 프로토콜과 헤더|간단한 인증 요구/응답 모델]] 참고.

## 12.2.1 기본 인증의 예
1. CLI: GET 메서드로 문서를 요청한다.
2. SRV: WWW-Authenticate에 어떤 영역(realm)의 비밀번호가 필요한지를 기술한 인증 요구를 401(Unauthorized) 응답에 실어 보낸다.
3. CLI: 인증 정보(사용자명 비밀번호)를 base-64로 인코딩한 후 Authorization 헤더에 넣어 문서 요청에 실어 보낸다.
4. SRV 인증 응답: 받은 인증 정보를 디코딩한 후 검사.
    1. 성공 시 서버는 세션 추가 정보를 Authentication-Info에 실어 요청 문서와 함께 200 OK로 응답한다. 
    2. 실패 시 인증 재요구나 실패 응답을 전송.

인증 요구 응답: `WWW-Authenticate: Basic realm="family"`
인증 요구 요청: `Authorization: Basic YnJpYW...`

## 12.2.2 base-64 사용자 이름/비밀번호 인코딩
- base64 인코딩이란: 8 bits 단위로 이루어진 문자열 시퀀스를 6 bits 단위로 쪼개고, 쪼갠 비트 덩어리를 64개의 문자 집합 중 대응하는 것으로 치환.
    - 이유: 
        - 통신에서 보낼 수 없는 데이터(바이너리, 특수문자 등)가 있어, 안전한 알파벳으로 모두 바꾸고자. 
        - 인증 정보가 그대로 드러나지 않게 바꿀 수 있다. (물론 쉽게 풀 수 있다.)
- HTTP 기본 인증이 base64를 사용해서 인증 정보를 전달하는 과정:
    1. 클라이언트는  인증 정보를 `<user>:<password>` 형식으로 기술한다.
    2. 인증 정보를 b64로 인코딩한다.

## 12.2.3 프락시 인증
- 프락시 인증으로 사용자 식별 가능.
- 이점: 접근 정책을 한 곳에서 관리(중앙 집중형). 
    ```mermaid
    flowchart TD
        proxy --> realm1
        proxy --> realm2
        proxy --> realm3
        subgraph server
            realm1
            realm2
            realm3
        end
    ```
- 프락시 인증과 서버 인증의 헤더와 상태 코드 비교
| 요소 | 웹 서버 | 프락시 서버 |
| -- | -- | -- |
| 비인증 상태 코드 | 401 | 407 |
| 인증 요청 |  WWW-Authenticate | Proxy-Authenticate |
| 인증 응답 | Authorization | Proxy-Authorization |
| 인증 세션 정보 | Authentication-Info | Proxy-Authentication-Info |

## 12.2.3 기본 인증의 보안 결함
- 기본 인증은 결함이 있어 사용이 제한되거나, 다른 암호화 기술과 병행하여 쓰인다.
- 결함:
    - b64 인코딩은 풀리기 쉽다.
        - 강화책: SSL 채널을 통해 트랜잭션 전송. 강화된 다이제스트 인증
    - 재전송 공격: 깨기 어려운 인코딩이라도 획득한 그대로 인증에 활용하여 침입 가능
    - 사용자들은 같은 인증 정보를 여러 곳에 재활용하는 경향이 있다.
    - 인증 헤더는 그대로 두고 다른 부분을 수정하여 요청의 동작을 바꿀 수 있다.
    - 가짜 서버로 사용자들을 유인해 인증 정보를 보내도록 한다.
- 