# 3.1 메시지의 흐름
- HTTP 메시지란: HTTP 어플리케이션 간 주고 받은 데이터 블록
- 메시지의 구성 요소
    - 텍스트 메타 정보(시작줄과 헤더 블록이 여기 해당)
    - 데이터(엔터티 본문이 해당되며, 메시지 내 존재하지 않을 수도 있음)

## 3.1.1 메시지는 최종 서버 방향을 인바운드로 하여 송신된다
- 서버-클라이언트 관점에서 바라본 메시지의 이동 방향
    - Inbound: 클라이언트 -> 서버
    - Outbound: 서버 -> 클라이언트

## 3.1.2 다운스트림으로 흐르는 메시지
- 수신자 발신자 관점에서 바라본 메시지 이동 방향
    - upstream: 수신자 -> 발신자(메시지는 이 방향으로 흐를 수 없음을 알 수 있다)
    - downstream: 발신자 -> 수신자(메시지는 오로지 downstream으로만 이동한다)

# 3.2 메시지의 각 부분
- 메시지 3구성
    - 시작줄
    - 헤더 블록
    - 엔터티 본문(필수 사항 아님, 텍스트나 바이너리 데이터)
- 메시지의 각 줄은 CRLF로 끝난다.

## 3.2.1 메시지 문법
- 메시지의 종류
    -   요청 메시지: 서버에 제출하는 요구 사항
    -   응답 메시지: 클라이언트에 제출하는 요청 결과

X | 요청 메시지 | 응답 메시지
-- | -- | --
시작줄 | `<메서드> <요청 URL> <HTTP ver.>` | `<버전> <상태 코드> <서유 구절>`
헤더 블록 | `<헤더>` | `<헤더> `
엔터티 본문 | `<엔터티 본문>` | `<엔터티 본문>`
- 메시지 시작줄
    -   메서드: 클라이언트가 서버에게 요청하는 동작. 예: GET, POST, HEAD, ….
    -   확장 메서드: HTTP 명세에 정의되지 않은 메서드.
    -   요청 URL: 메서드의 적용 대상이 되는 리소스를 가리키는 절대 URL 혹은 경로 컴포넌트.
    -   버전: 메시지를 발송한 애플리케이션이 지원하는 가장 높은 HTTP 버전.
    -  해석 시 주의점: 1.3보다 1.22가 더 최신이다.
    -   상태 코드: 요청 결과가 어떤지 알려주는 세 자리 숫자. 가장 왼쪽 자리 숫자는 상태의 일반적인 분류를 나타낸다. (예: 1__은 정보, 2__는 성공, ….)
    -   사유 구절(reason-phrase): 상태 코드의 의미를 설명해주는 문자열. 사유 구절은 상태 코드와 달리 임의적이다. 200 “OK”든, 200 “Not OK” 든 기계는 동일한 의미로 받아들인다.
-   헤더들: `<header>: <value>`로 구성돼 있으며 메시지에 대한 메타 정보를 나타낸다. 헤더 블록의 끝은 CRLF로만 이루어져 있다. 헤더의 종류는 3.2.3 헤더에서 설명한다.
-   엔터티 본문: 필수 항목은 아니며, 여기에는 요청을 수행하는데 필요한 데이터 혹은 클라이언트가 요청했던 데이터가 들어 있다.

## 3.2.2 시작줄
(이 장의 내용은 3.2.1에 모두 욱여넣었다.)

## 3.2.3 헤더
- 헤더 분류
    -   일반 헤더
    -   요청 헤더
    -   응답 헤더
    -   엔터티 헤더
    -   확장 헤더

-   헤더 하나를 여러 줄로 나눠 작성
    ```
    HTTP/1.0 200 OK
    Content-Type: image/gif
    Content-Length: 8572
    Server: Test Server
    Version 1.0
    ```
## 3.2.4 엔티티 본문
(이 장의 내용은 3.2.1에 모두 욱여넣었다.)

## 3.2.5 버전 0.9 메시지
지나치게 단순한 규약이란 문제점이 있다.

# 3.3 메서드
모든 서버는 모든 메서드를 구현할 의무는 없지만, HTTP 1.1에 의하면 HEAD와 GET은 필수로 구현해야 한다.

### 3.3.1 안전한 메서드
- '안전한'의 의미: 실행 전후 서버 상태의 변화가 없다.
- 안전하지 않은 메서드가 실행되면 이를 클라이언트에게 알려줘야 한다.

## 3.3.2 GET
- 서버에게 지정된 리소스를 응답에 실어 보내길 요청한다.
- HTTP 1.1 구현 요구 사항

## 3.3.3 HEAD
- HTTP 1.1 구현 요구 사항
- GET과 동일하나 엔티티 바디를 빼고 (헤더만) 응답한다는 점이 차이. 서버 개발자는 그 점만 다르도록 구현해야 한다
- 용도
    - 리소스 반환 없이 메타 정보를 얻는다
    - 응답의 상태 코드만을 검사

## 3.3.4 PUT
- 서버에 문서를 쓰는 작업
- 예시 요청
    ```
    PUT /product-list.txt HTTP/1.1
    Host: www.joes-hardware.com
    Content-Type: text/plain
    Content-Length: 34

    Update prudoct list coming soon!
    ```
- 지정된 경로 조각에 문서가
    - 없으면 -> 새 문서
    - 있으면 -> 갱신
- 메소드 실행 전에 사용자 인증을 요구하는 경우가 있다.

## 3.3.5 POST
- 용도: 서버에 (주로 form을 통해 들어온) 입력 데이터 전송

## 3.3.6 TRACE
- 용도: 최종 서버에 도달한 시점에서 요청이 어떤 모습을 하고 있는지 확인
- 이를 어떻게 구현: Loopback 진단으로.
    - 최종 서버는 받은 요청 메시지를 엔티티 본문에 담아 이를 응답으로 돌려준다.
- 요구사항: TRACE 요청 엔티티 본문은 비어 있어야 한다.
- 문제점: 모든 메소드가 동일하게 동작할 것이라 가정하고 동작
    - 예: 프록시는 POST를 서버에게 전달되지만, GET이라면 최신의 캐시가 있는 경우 거기로 요청을 보낼지도 모른다.

## 3.3.7 OPTIONS
- 역할: 웹 서버가 어떤 메소드를 지원하는지 물어본다.
- 용도: 시행착오를 거치며 서버가 지원할 수 있는 범위를 확인하는 대신, 이 메소드로 그런 수고를 없앨 수 있다.
- 예:
    ```
    # 요청
    OPTIONS * HTTP/1.1 
    Host: www.joes-hardware.com
    Accept: *
    
    # 응답
    HTTP/1.1 200 OK
    Allow: GET, POST, PUT, OPTIONS
    Context-length: 0
    ```
## 3.3.8 DELETE
- 역할: 서버 내 지정된 경로에 있는 리소스의 삭제를 요청.
- 주의점: 서버가 보낸 응답 내용과 실제 실행 결과 사이에는 필연성이 없다.

## 3.3.9 확장 메소드
- 용도: HTTP/1.1에서는 명세로 정의되지 않았으나 필요한 경우 서버는 메소드를 만들 수 있다.
- 주의점
    - 서버와 클라이언트 어느 한 쪽만 정의된 경우 인터페이스가 다르니 상대는 메소드를 이해하지 못한다.
    - 설령 같은 이름의 메소드를 정의했어도, 실제 작동이 서로가 기대한 대로가 아닐 수 있다.

# 3.4 상태 코드

## 3.4.1 100-199: 정보성 상태 코드
- HTTP 1.1에서 도입
- 100
    - 목적: 클라이언트에게 서버가 다룰 수 없는 데이터를 보내지 말도록 지시
    1. 클라이언트는 `Expect: 100-continue` 헤더를 포함한 요청을 보낸다.
    2. 서버는 엔터티를 받아들일지 여부를 응답에 실어 보낸다.
        1. 받아들이겠다면 응답에 `100` 상태 코드를 보낸다.
        2. 받아들이지 않겠다면 응답에 그 외 코드(413, 417 등)를 보낸다.
    3. 응답 상태 코드가 `100`이면 메시지를 이어 보내라(만약 응답이 없다면 타임아웃 후 이어 보내라)

## 3.4.2 200-299: 성공 상태 코드

## 3.4.3 300-399: 리다이렉션 상태 코드
- 클라이언트가 찾는 리소스의 다른 위치
- 리소스 내용 대신 대안
- HEAD가 아닌 요청의 경우에는 리다이렉트 될 URL과 그 설명을 포함시켜라.

## 3.4.4 클라이언트 에러 상태 코드
- 원인: 클라이언트가 서버가 다룰 수 없을 요청을 보낸 경우

## 3.4.5 서버 에러 상태 코드
- 원인: 클라이언트가 타당한 요청을 보냈더라도 서버에서 문제가 생긴 경우 이 코드를 보낸다.

# 3.5 헤더
- 종류
    - General headers
        - 역할: 응답 혹은 요청 어느 쪽 메시지든 공통으로 지니는 정보를 표현
        - 일반 캐시 헤더
            - 역할: 원래 리소스를 지닌 서버 대신 캐시로부터 리소스를 획득
    - Request headers
        - 역할: 서버에게 필요한 클라이언트 정보를 제공
        - Accept 관련 헤더
            - 역할: 클라이언트가 어떤 데이터를 받을 수 있는지 알려준다.
        - 조건부 요청 헤더
            - 역할: 응답하기 전에 먼저 이 헤더의 조건이 참인지부터 확인하게 시킨다
        - 요청 보안 헤더
            - 역할: 클라이언트가 먼저 자신의 인증 정보를 여기 기술한다
        - 프락시 요청 헤더
            - 역할: 트랜잭션 중 거쳐 가는 프락시에 대해 기술
    - Response headers
        - 역할: 클라이언트에게 필요한 서버 정보를 제공
        - 협상 헤더
            - 역할: 보낼 수 있는 리소스가 복수라면 그 중 무엇을 택할지 협상하도록 지원
        - 응답 보안 헤더
            - 역할: 클라이언트에게 인증을 요구하는 경우
    - Entity headers:
        - 역할: 엔티티 본문에 대한 정보를 제공
        - 콘첸츠 헤더: 엔터티 내 콘텐츠에 대한 정보
        - 엔터티 캐싱 헤더: 컨텐츠의 캐시를 언제 다시 해야 할지 같은 정보 제공
    - Extension headers
        - 역할: HTTP 명세에는 없으며 임의로 정의된 헤더
