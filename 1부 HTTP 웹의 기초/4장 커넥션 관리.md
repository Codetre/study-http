- 이 장의 주요 질문:
    - HTTP가 어떻게 TCP 커넥션을 사용하는가
    - TCP 커넥션의 지연, 병목, 막힘
    - HTTP 최적화: 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인
    - 커넥션 관리를 위해 따라야 할 규칙들

# 4.1 TCP 커넥션
- HTTP 통신은 TCP 통신을 기반으로 이루어진다.
- TCP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 사용한다.
- TCP 커넥션은  신뢰성 있는(데이터 순서 꼬임, 소실 방지) 데이터 교환을 보장한다.
- TCP 커넥션을 맺고 통신하는 과정
    1. URL을 분석하여 IP주소와 포트 번호를 획득
    2. 획득한 정보로 TCP 커넥션 생성
    3. 요청과 응답을 주고 받는다
    4. 커넥션을 닫는다

## 4.1 신뢰할 수 있는 데이터 전송 통로인 TCP 커넥션
- HTTP 커넥션은 TCP 커넥션에 몇 가지만 추가한 것일 뿐이다.

## 4.1.2 TCP 커넥션의 통신 단위
- TCP 스트림은 **세그먼트**로 나뉘어 **IP 패킷(IP 데이터크램)**을 통해 전송된다
- 데이터 분할 과정
    1. HTTP 계층에서 넘어온 메시지를 TCP 계층에서 세그먼트 단위로 분할한다.
    2. 세그먼트는 IP 패킷으로 포장된다.
- IP 패킷에 담기는 주요 정보
    - IP 패킷 헤더(약 20 bytes): 발신/수신지의 IP주소
    - TCP 세그먼트 헤더(약 20bytes): TCP 포트 번호, TCP 제어 플래그, 데이터 무결성 검사용 값
    - TCP 데이터 조각(0 bytes 이상): HTTP 메시지 조각

## 4.1.3 TCP 커넥션 유지하기
- IP 주소: 통신 장치(HW)의 주소
- Port 번호: 통신 장치 내 설치된 어플리케이션(SW)마다 고유하게 할당된 정수값 주소
- TCP 커넥션 식별 요소(하나라도 다르면 다른 커넥션)
| 방향/창구 | IP 주소 | Port 번호 |
| -- | -- | -- |
| 발신 | 발신지 IP 주소 | 발신지 Port 번호 |
| 수신 | 수신지 IP 주소 | 수신지 Port 번호 |

## 4.1.4 TCP 소켓 프로그래밍
- endpoint: IP 주소 + port 번호
- TCP 커넥션은 연결의 양 끝을 socket이라는 개념으로 추상화했다.
- socket API는 이러한 TCP 커넥션을 맺고 끊는 과정까지를 제어하는 인터페이스다.
- 단일 HTTP transaction을 위해 TCP conn을 맺고 끊기까지의 과정 설명
| 클라이언트 | 서버 |
| -- | -- |
| - | 1. 새 소켓 생성 |
| - | 2. 80번 포트로 소켓을 묶는다 |
| - | 3. 소켓 커넥션을 허용한다 |
| - | 4. 커넥션을 기다린다 |
| 1. IP 주소와 포트를 획득 | - |
| 2. 새 소켓 생성 | - |
| 3. 서버로 소켓을 연결한다 | - |
| - | 5. 어플리케이션 커넥션 통지 |
| 4. 연결 성공 | - |
| 5. 요청 전송 | - |
| 6. 응답 대기 | 6. 요청 읽기 및 처리 |
| - | 7. 응답 전송 |
| 7. 응답 처리 | - |
| 8. 커넥션 종료 | 8. 커넥션 종료 |

# 4.2 TCP 성능에 대한 고려
- HTTP 통신은 TCP 커넥션에 기반해 이루어지므로 저수준까지 고려하는 성능 최적화를 위해서는 TCP 커넥션 부분에 대해 이해하고 있어야 한다.

## 4.2.1 HTTP 트랜잭션 지연
- 지연은 다음 단계에서 발생한다:
    1. DNS 찾기: DNS resolution 인프라가 IP 주소와 포트 번호를 획득하는데 걸리는 지연
    2. TCP 커넥션 맺기: 새로운 커넥션을 맺어야 한다면 커넥션 요청을 보내고 이에 대한 응답을 기다리는 기다리는 동안 지연 발생
    3. 요청 메시지 발송: 메시지는 TCP 파이프를 통해 이동하며 그 동안 지연 발생
    4. 요청 메시지 처리: 요청 처리에도 시간은 걸리나 나머지에 비해 상대적으로 짧은 지연이다
    5. 응답 메시지 발송: 요청 메시지 발송과 마찬가지인 지연이다
    6. 커넥션 끊기

## 4.2.2 성능 관련 중요 요소
- HTTP 어플리케이션의 통신 성능에 영향을 미치는 TCP 계층의 문제 중에는 다음과 같은 것들이 있다:
    - TCP 커넥션 핸드셰이크 설정(4.2.3)
    - TCP 느린 시작(4.2.5)
    - 데이터를 모아 한 번에 전송하는 Nagle 알고리즘(4.2.6)
    - TCP 편승(piggyback) 확인응답(acknowledgement)을 위한 확인응답 지연 알고리즘(4.2.4)
    - TIME_WAIT 지연과 포트 고갈

## 4.2.3 TCP 커넥션 핸드셰이크 지연
- 핸드셰이크:  TCP 커넥션을 맺는 과정. 모든 HTTP 메시지를 시작하기 위한 전초 단계이다. 이런 핸드셰이크는 커넥션을 맺기 위한 정보를 담은 IP 패킷 교환에서 시작한다.
- 순서: 이런 과정은 HTTP 계층에서 보이지 않게 추상화 돼 있다.
    1. (Client) `SYN` 플래그를 지닌 IP 패킷 전송: 커넥션 생성을 요청한다.
    2. (Server) `SYN` `ACK` 플래그를 지닌 패킷 전송: 커넥션 매개변수를 요청에서 추출하고 문제가 없다면 연결을 맺겠다는 응답을 보낸다.
    3. (Client) `ACK` 플래그를 지닌 **확인 응답** 전송: 커넥션 연결 성공을 알리며, 여기에 데이터를 같이 실어 보낼 수 있다.
- 이 과정은 메시지가 작을수록 큰 지연이 되며, 이런 지연을 최대한 줄여보기 위해 커넥션을 재사용한다.

## 4.2.4 확인응답 지연
- TCP에는 자체적인 데이터 전송 확인 체계를 지닌다.
- 수신자가 세그먼트를 받으면 이에 대해 확인 응답 패킷을 전송한다.
- 확인 응답 패킷은 크기가 작아 같은 방향으로 향하는 패킷에 이 확인 응답 패킷을 '편승(piggyback)'시킨다.
- 확인 응답 지연 알고리즘: 편승 발생 확률을 높이기 위한 알고리즘
    1. 확인 응답 패킷을 버퍼에 저장해 둔다.
    2. 일정 시간 동안 편승시킬 패킷을 찾는다.
    3. 찾지 못한다면 별도의 패킷으로 확인 응답 패킷을 전송한다.
- 확인 응답 지연 알고리즘 때문에 지연이 생기는 경우 이 기능을 비활성화 할 수 있지만, 이런 설정은 주의를 기울여 건드려야 한다.

## 4.2.5 TCP 느린 시작(slow start)
- 느린 시작: TCP 커넥션은 막 생성된 시점에서는 느리지만 데이터 전송이 성공함에 따라 속도가 높아지는 '튜닝' 과정을 거친다.
- Open the congestion window: 속도를 올리는 방법은 다음과 같다.
    1. 1개의 패킷을 보내고, 확인 응답을 받는다.
    2. 성공 시 다음에는 2개의 패킷을 보낼 권한이 커넥션에 생긴다.
    3. 다시 성공시 이번에는 4개의 패킷을 보낼 권한이 생긴다...
    4. 이런 식으로 한번에 보낼 수 있는 패킷의 양이 증가한다.

## 4.2.6 Nagle 알고리즘과 TCP_NODELAY
- 패킷에서 데이터가 작을수록 차지하는 헤더의 양이 크다.
- 이런 부하를 막기 위해 데이터가 작은 패킷들을 하나로 합치는 알고리즘이 바로 Nagle 알고리즘이다.
    - 과정:
    1. 최대 패킷 크기에 도달하지 않은 패킷은 버퍼에 둬 전송을 지연한다.
    2. 언제 패킷을 보내는가:
        1. 다른 모든 패킷이 확인 응답을 받은 경우(마지막 패킷인 경우) 전송을 보낸다.
        2. 버퍼가 쌓이면 저장된 데이터를 한꺼번에 전송한다.
    - 단점: 성능 저하를 야기할 수 있다.
        - 메시지의 크기가 작은 경우
        - 확인 응답 지연 알고리즘과 같이 쓰일 경우

## 4.2.7 TIME_WAIT의 누적과 포트 고갈

# 4.3 HTTP 커넥션 관리
- 커넥션 생성과 최적화 기술
    - 커넥션 헤더
    - 커넥션 최적화

## 4.3.1 Connection Header에 대한 오해
- HTTP 커넥션의 종단인 클라이언트와 서버 사이에는 프록시 등 다른 장비가 노드로 끼어들 수 있다.
- HTTP Connection header는 
    - hop-by-hop 헤더이다. (인접 노드 간 연결을 넘어 전달되지 않는다)
    - 쉼표로 구분되는 커넥션 토큰을 값으로 지닌다.
        - 토큰의 종류:
            - HTTP header field명: 현재 노드 간 커넥션에만 유지되는 hop-by-hop 헤더들을 기술.
            - 임시적인 토큰 값: 비표준 옵션. 인식하지 못하는 노드에서는 이를 무시한다.
            - close: 커넥션 작업이 완료되면 종료시킬 것을 지시.

## 4.3.2 트랜잭션 순차 처리로 인한 지연
- 순차 처리의 문제점:
    - 하나의 작업을 처리하기 위한 일련의 transaction마다 새 커넥션을 맺어야 한다.
    - 작업이 완료되는 동안 사용자는 지루함을 느낀다.
    - 브라우저가 페이지를 불러오기 위해서 나머지 객체들의 크기를 알아야 하나 이를 받아오지 못했으니 렌더링이 불가능하다.
- 이런 지연을 해소하기 위한 기법들이 있다:
    - parallel connection(4.4)
    - persistent connection(지속 커넥션)(4.5)
    - pipelined connection(4.6)
    - multiplexed connection(다중 커넥션)

# 4.4 병렬 커넥션
- 한 번에 복수의 커넥션을 맺는다. 각 커넥션의 목적지는 다를 수 있기에(이미지는 전용 storage에, HTML 문서는 웹 서버에 둔 경우) 이를 가능하게 구현해야 한다.
- 단점:
    - 새 커넥션 연결 구성을 위한 지연이 생긴다
    - 새 커넥션은 느리게 시작(slow start)한다.
    - 서버에 무리가 가지 않도록 실제 연결 수에 제한을 둬야 한다.
## 4.4.1 더 빠른 페이지 불러오기
- 대역폭이 남는 경우 이를 새로운 병렬 커넥션을 맺는데 사용.
## 4.4.2 최적화 효과를 보지 못하는 경우
- 새 커넥션을 맺을 여유가 대역폭에 없는 경우: 커넥션 생성으로 인한 지연까지 합쳐져 더 손해.
- 커넥션이 자원을 소모하는 경우: 클라이언트 입장에서는 커넥션 몇 개지만, 서버 입장에서는 이러한 커넥션이 n배로 늘어나는셈.
    - 대책: 이를 피하기 위해 클라이언트가 한 번에 열 수 있는 병렬 커넥션의 수를 제한해야 함.
## 4.4.3 심리적 만족 효과
- 실제로는 더 느리더라도 여러 객체가 한 번에 뜨는 모습이 심리적으로는 더 빠르게 느껴진다.

# 4.5 지속 커넥션
- 사이트 지역성(site locality): 한 번 리소스를 요청했던 서버에는 가까운 시간 내 다른 리소스를 요청할 가능성이 높다.
- 사이트 지역성에 따르면 작업 완료 후에도 커넥션을 유지하면 또 써먹을 데가 있단 뜻.
- 지속 커넥션: 이렇게 transaction 처리 후에도 종료되지 않고 남은 커넥션.

## 4.5.1 지속 커넥션 vs 병렬 커넥션
- 지속 커넥션이 병렬 커넥션에 비해 지닌 우위점:
    - 새로운 커넥션에 필요한 지연이 필요 없다.
    - 이미 존재하는 커넥션은 튜닝됐기에 빠르다.
    - 커넥션의 수를 늘리지 않아도 된다.
- 지속 커넥션이 병렬에 비해 지닌 단점:
    - 잘못 관리할 경우, 죽지 않고 남은 커넥션들이 불어난다.
- 이상적인 형태: 적은 수의 병렬 커넥션을 맺고 이를 유지.
- 구현된 종류:
    - keep-alive(HTTP/1.0+)(4.5.2~4.5.6)
    - 지속 커넥션(HTTP/1.1)

## 4.5.2 Keep-Alive(HTTP/1.0+)
(transaction마다 별도 connection이 아닌, 하나의 connection을 통해 처리한다는 내용)

## 4.5.3 Keep-Alive 동작
- HTTP/1.1부터 deprecated지만, 그 전 서버들과 호환을 위해 이를 구현해 두는 것이 좋다.
- 요청:
    ```
    GET /index.htm l HTTP/1.0
    Host: www.joes-hardware.com
    Connection: Keep-Alive  # 지속 커넥션을 맺고 싶다.
    ```
- 응답(`Connection` 헤더가 없으면 연결 종료로 간주):
    ```
    HTTP/1.0 200 OK
    Content-Type: text/html
    Content-Length: 3104
    Connection: Keep-Alive  # 커넥션을 유지하고 다음 메시지도 이를 통해 받겠다.
    ```

## 4.5.4 Keep-Alive 옵션
- Keep-Alive를 받았다고 이를 따른다는 보장은 없다.
- 제어 옵션(`Keep-Alive`헤더의 값):
    - timeout: 유지 시간(단위 초)
    - max: 최대 처리 transaction 수
    - 예시: 
        ```
        Connnection: Keep-Alive
        Keep-Alive: max=5, timeout=120
        ```

## 4.5.5 Keep-Alive 커넥션 제한과 규칙
- HTTP/1.0 기본 사항이 아님: 이를 활성화하려면 요청 헤더에 `Connection: Keep-ALive`를 넣어야 한다.
- 메시지 간 지속되지 않음: 유지를 원하는 메시지에 매번 `Connection: Keep-Alive` 헤더를 포함시킬 것.
- 엔터티 본문의 크기를 사전에 알아야 함: `Content-Length` 명시한 multipart media type 혹은 청크 전송 인코딩(매 청크는 자신의 크기가 명시돼 있음)이 되어야 함.
- 경유 노드는 다음 노드로 전달 전에 `Connection` 헤더를 반드시 삭제하고 보내야 함
- HTTP/1.0 이전 버전 노드에게 온 커넥션 유지는 무시할 것
- 클라이언트는 응답을 모두 받기 전 커넥션이 끊어졌다면 다시 요청을 보낼 준비를 해야 함.


## 4.5.6 Keep-Alive와 멍청한(dumb) 프록시
- dumb 의미: 이해하지 못하는 헤더를 그대로 다음 hop으로 넘긴다. `Connection`이 hop-by-by임을 모르고 다음 노드로 넘긴다.
| 클라이언트 | 멍청한 프록시 | 서버 |
| -- | -- | -- |
| 1. `Connection: Keep-Alive` 메시지 전송 | - | - |
|  | 2. 메시지 **그대로** 전달 | - |
| - | - | 3. `Connection: Keep-Alive` 응답 전송(프록시와 커넥션 유지) |
| - | 4. 응답 그대로 클라이언트에게 전달 | - |
| 5. 서버와 커넥션이 맺어졌다고 생각하며 요청 전송 | - | - |
| - | 6. 서버와 커넥션이 유지된 상태이므로 hang에 걸려 무시됨 | - |

- 이 문제를 해소하려면 프록시는 홉별 헤더인 `Connection`을 절대 다음 노드로 전달해서는 안된다.


## 4.5.7 Proxy-Connection 살펴 보기
- 멍청한 프록시 문제를 확장 헤더인 `Proxy-Connection`헤더로 해결하는 시도
- (대부분) 프락시는 `Proxy-Connection`을 이해할 수 있어 이를 `Connection`으로 바꿔 전달.
- 프락시가 이를 다음 홉으로 넘겨도 서버는 `Proxy-Connection`을 이해하지 못해 무시함.
- 프락시가 `Proxy-Connection`을 이해 못하는 경우:
| 클라이언트 | 멍청한 프록시 | 서버 |
| -- | -- | -- |
| 1. `Proxy-Connection: Keep-Alive` 메시지 전송 | - | - |
|  | 2. 메시지 **그대로** 전달 | - |
| - | - | 3. `Proxy-Connection: Keep-Alive` 를 무시 후 응답 전송 |
| - | 4. 비지속 커넥션 응답 전달 | - |
| 5. 서버가 커넥션을 유지하지 않을 것임을 알게 됨 | - | - |
- 프락시가 `Proxy-Connection`을 이해하는 경우: 
| 클라이언트 | 멍청한 프록시 | 서버 |
| -- | -- | -- |
| 1. `Proxy-Connection: Keep-Alive` 메시지 전송 | - | - |
|  | 2. `Proxy-Connection`을 `Connection`으로 변환해 전달 | - |
| - | - | 3. 커넥션 수락 응답 |
| - | 4. 커넥션 유지 응답 전달 | - |
- 문제점: 경로가 'client-proxy-server'이 세 노드로만 이루어져 있어야 한다. 멍청한 proxy가 하나라도 끼게 되면 실패한다.


## 4.5.8 HTTP/1.1 지속 커넥션
- Keep-Alive와 달리 기본적으로 활성화돼 있다.
- 연결 해제는 `Connection: CLose`로 명시해야 한다.
- 연결 해제 헤더가 없다 해서 서버나 클라이언트가 이를 계속 유지할 보장은 없다.


## 4.5.9 지속 커넥션 제한과 규칙
- 클라이언트는 한번 닫은 커넥션으로 다른 요청을 보낼 수 없다.
- 커넥션 상 마지막 메시지에는 `Connection: close` 헤더를 붙여 보내라.
- 커넥션을 통과하는 모든 메시지는 자신의 길이 정보를 지녀야만 한다(4.5.5 참조).
- 중간에 낀 프락시는 클라이언트와 서버 각각에 대해 커넥션을 유지해야 한다.
- 트랜잭션 중간에 끊어진 커넥션은 복구할 수 있어야 한다.
- 중간에 끊어진 경우 멱등한 요청일 경우 이를 다시 보낼 준비를 해야 한다.
- 클라이언트는 병렬로 최대 2개의 커넥션을 유지할 수 있으며, 서버는 2N(N은 클라이언트 수)개의 커넥션을 유지할 수 있어야 한다.


# 4.6 파이프라인 커넥션
- 전제 조건: 지속 커넥션이 연결돼 있어야 한다.
- 다음 요청들은 큐에 쌓이며, 이전 요청에 대한 응답이 오기를 기다리지 않고 발송된다.
- 제약 사항:
    - 지속 커넥션인지 확인 전까지 파이프라인 요청을 보내서는 안된다.
    - 응답은 요청 순서와 동일해야 한다. HTTP 메시지에는 순번이 적혀 있지 않다.
    - 커넥션이 예상치 못하게 끊어지더라도 응답을 받지 못한 요청을 다시 보낼 준비가 돼야 한다.
    - 비멱등(nonidempotent) 요청은 파이프라인으로 보내면 안된다.
        - 이유: 에러 발생 시 처리된 요청과 그렇지 못한 요청을 구분할 수 없기에.
        - 이런 요청은 응답까지 받고 다음 요청을 보내는 순차 커넥션으로만 보내야 안전하다.


# 4.7 커넥션은 언제 끊어야 할까
- 커넥션 종료에 대해 HTTP 명세에 기준이 없어 어려움.

## 4.7.1 '마음대로' 커넥션 끊기
- 노드 중 어떤 것도 아무 시점에 커넥션을 끊을 수 있다.
    - 정상 상황: 트랜잭션 완료 후 끊는다.
    - 비정상 상황: 완료되지 않아도 끊길 수 있다. 예) timeout이어서 서버는 끊었는데, 그 순간 클라이언트가 요청을 전송한 경우.

## 4.7.2 Content-Length와 Truncation
- 모든 응답에는 엔터티 본문의 정확한 크기를 알려주는 `Content-Length` 헤더가 있어야 한다.
- 응답 속 `Content-Length` 헤더가 실제 크기와 다르거나 존재하지 않으면 정확한 크기를 서버에게 요청해야 한다.
- 캐시 프락시는 서버로부터 받은 응답을 수정하지 말고 그대로 클라이언트에게 전달해야 한다.

## 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성
- 에러가 없어도 커넥션은 끊길 수 있고, 이럴 때도 어플리케이션은 대응할 수 있어야 한다.
    - 클라이언트는 다시 커넥션을 맺어 요청을 보낼 준비를 해야 한다.
    - 비멱등한 요청의 경우:
        - 클라이언트는 이를 파이프라인으로 보내선 안된다.
        - 다시 보내야 한다면 응답을 받을 때까지 기다려야 한다.
        - 자동으롤 재시도를  해선 안된다.

## 4.7.4 우아하게 끊기
- 커넥션은 양방향이다.
- 클라이언트와 서버 각각은 입력/출력 큐를 갖추고 있다.
- 전체 끊기: 노드의 입출력 큐를 모두 끊는다(`close()`).
- 절반 끊기: 노드의 입출력 중 한 쪽만 끊는다(`shutdown()`).
- 언제 절반을 끊어야 하는가?
    - 여러 HTTP 클라이언트, 서버, 프락시와 통신 중인 경우
    - 파이프라인 지속 커넥션을 유지 중인 경우
    - 기기들에 예상치 못한 쓰기 에러를 발생 시킨 경우
- 어떤 채널을 끊어야 하는가: 출력 채널
    - 입력 채널을 끊으면 발생하는 문제: 
        1. 끊어진 입력 채널로 요청이 들어오면 서버 OS는 `connection reset by peer`을 전송한다.
        2. 클라이언트는 이 메시지를 받고 입력 버퍼를 비운다(connection reset).
- 우아한 연결 종료란:
    - HTTP 명세에서는 구현에 대해 언급하지 않음.
    - 어플리케이션이 자신의 출력을 끊고 상대쪽의 출력이 끊기기를 기다린다(reset을 방지하기 위해)
    - 입력 채널에 대해 지속적인 상태 검사를 해 데이터의 끝을 식별해야 한다.